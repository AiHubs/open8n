import { completeFromList } from '@codemirror/autocomplete';
import { LRParser } from '@lezer/lr';
import { foldNodeProp, foldInside, LRLanguage, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "nQQOPOOOOOO'#Cc'#CcOOOO'#Ca'#CaQQOPOOOOOO-E6_-E6_",
  stateData: "]~OQPORPOSPO~O",
  goto: "cWPPPPPXP_QRORSRTQOR",
  nodeNames: "âš  Program Plaintext Resolvable BrokenResolvable",
  maxTerm: 7,
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "6v~RRO#o[#o#p{#p~[~aRQ~O#o[#o#pj#p~[~mRO#o[#p~[~~v~{OQ~~!OSO#o[#o#p![#p~[~~v~!a!YS~OX&PX^![^p&Ppq![qr![rs![st![tu![uv![vw![wx![xy![yz![z{![{|![|}![}!O![!O!P![!P!Q![!Q![![![!]![!]!^![!^!_![!_!`![!`!a![!a!b![!b!c![!c!}![!}#O![#O#P&d#P#Q![#Q#R![#R#S![#S#T![#T#o![#o#p![#p#q![#q#r6n#r#s![#s#y&P#y#z![#z$f&P$f$g![$g#BY&P#BY#BZ![#BZ$IS&P$IS$I_![$I_$I|&P$I|$JO![$JO$JT&P$JT$JU![$JU$KV&P$KV$KW![$KW&FU&P&FU&FV![&FV~&P~&URS~O#q&P#q#r&_#r~&P~&dOS~~&i!YS~OX&PX^![^p&Ppq![qr![rs![st![tu![uv![vw![wx![xy![yz![z{![{|![|}![}!O![!O!P![!P!Q![!Q![![![!]![!]!^![!^!_![!_!`![!`!a![!a!b![!b!c![!c!}![!}#O![#O#P&d#P#Q![#Q#R![#R#S![#S#T![#T#o![#o#p![#p#q![#q#r*X#r#s![#s#y&P#y#z![#z$f&P$f$g![$g#BY&P#BY#BZ![#BZ$IS&P$IS$I_![$I_$I|&P$I|$JO![$JO$JT&P$JT$JU![$JU$KV&P$KV$KW![$KW&FU&P&FU&FV![&FV~&P~*^}S~X^-Zpq-Zqr-Zrs-Zst-Ztu-Zuv-Zvw-Zwx-Zxy-Zyz-Zz{-Z{|-Z|}-Z}!O-Z!O!P-Z!P!Q-Z!Q![-Z![!]-Z!]!^-Z!^!_-Z!_!`-Z!`!a-Z!a!b-Z!b!c-Z!c!}-Z!}#O-Z#O#P0Z#P#Q-Z#Q#R-Z#R#S-Z#S#T-Z#T#o-Z#o#p-Z#p#q-Z#q#r6Z#r#s-Z#y#z-Z$f$g-Z#BY#BZ-Z$IS$I_-Z$I|$JO-Z$JT$JU-Z$KV$KW-Z&FU&FV-Z~-^}X^-Zpq-Zqr-Zrs-Zst-Ztu-Zuv-Zvw-Zwx-Zxy-Zyz-Zz{-Z{|-Z|}-Z}!O-Z!O!P-Z!P!Q-Z!Q![-Z![!]-Z!]!^-Z!^!_-Z!_!`-Z!`!a-Z!a!b-Z!b!c-Z!c!}-Z!}#O-Z#O#P0Z#P#Q-Z#Q#R-Z#R#S-Z#S#T-Z#T#o-Z#o#p-Z#p#q-Z#q#r6h#r#s-Z#y#z-Z$f$g-Z#BY#BZ-Z$IS$I_-Z$I|$JO-Z$JT$JU-Z$KV$KW-Z&FU&FV-Z~0^}X^-Zpq-Zqr-Zrs-Zst-Ztu-Zuv-Zvw-Zwx-Zxy-Zyz-Zz{-Z{|-Z|}-Z}!O-Z!O!P-Z!P!Q-Z!Q![-Z![!]-Z!]!^-Z!^!_-Z!_!`-Z!`!a-Z!a!b-Z!b!c-Z!c!}-Z!}#O-Z#O#P0Z#P#Q-Z#Q#R-Z#R#S-Z#S#T-Z#T#o-Z#o#p-Z#p#q-Z#q#r3Z#r#s-Z#y#z-Z$f$g-Z#BY#BZ-Z$IS$I_-Z$I|$JO-Z$JT$JU-Z$KV$KW-Z&FU&FV-Z~3^}X^-Zpq-Zqr-Zrs-Zst-Ztu-Zuv-Zvw-Zwx-Zxy-Zyz-Zz{-Z{|-Z|}-Z}!O-Z!O!P-Z!P!Q-Z!Q![-Z![!]-Z!]!^-Z!^!_-Z!_!`-Z!`!a-Z!a!b-Z!b!c-Z!c!}-Z!}#O-Z#O#P0Z#P#Q-Z#Q#R-Z#R#S-Z#S#T-Z#T#o-Z#o#p-Z#p#q-Z#q#r6Z#r#s-Z#y#z-Z$f$g-Z#BY#BZ-Z$IS$I_-Z$I|$JO-Z$JT$JU-Z$KV$KW-Z&FU&FV-Z~6`PR~#q#r6c~6hOR~~6kP#q#r6c~6sPS~#q#r6c",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  tokenPrec: 0
});

const parserWithMetaData = parser.configure({
    props: [
        foldNodeProp.add({
            Application: foldInside,
        }),
        styleTags({
            OpenMarker: tags.brace,
            CloseMarker: tags.brace,
            Plaintext: tags.content,
            Resolvable: tags.string,
            BrokenResolvable: tags.className,
        }),
    ],
});
const n8nExpressionLanguage = LRLanguage.define({
    parser: parserWithMetaData,
    languageData: {
        commentTokens: { line: ";" },
    },
});
const completions = n8nExpressionLanguage.data.of({
    autocomplete: completeFromList([
        { label: "abcdefg", type: "keyword" },
    ]),
});
function n8nExpression() {
    return new LanguageSupport(n8nExpressionLanguage, [completions]);
}

export { n8nExpression, n8nExpressionLanguage, parserWithMetaData };
