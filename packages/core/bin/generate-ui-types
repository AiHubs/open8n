#!/usr/bin/env node

const { LoggerProxy, NodeHelpers } = require('n8n-workflow');
const { PackageDirectoryLoader } = require('../dist/DirectoryLoader');
const { packageDir, writeJSON } = require('./common');

LoggerProxy.init({
	log: console.log.bind(console),
	warn: console.warn.bind(console),
});

function findReferencedMethods(obj, refs = {}, latestName = '') {
	for (const key in obj) {
		if (key === 'name' && 'group' in obj) {
			latestName = obj[key];
		}

		if (typeof obj[key] === 'object') {
			findReferencedMethods(obj[key], refs, latestName);
		}

		if (key === 'loadOptionsMethod') {
			refs[latestName] = refs[latestName]
				? [...new Set([...refs[latestName], obj[key]])]
				: [obj[key]];
		}
	}

	return refs;
}

function generateHttpRequestVariantNodes(knownCredentials, credentialTypes, httpNode, version) {
	return Object.values(credentialTypes)
		.filter((credential) => 'httpRequestNodeVariant' in credential.type)
		.map((credential) => {
			const credentialType = credential.type;
			const hasSupportedNodes = knownCredentials[credential.name]?.supportedNodes?.length > 0;
			const httpIcon = httpNode.description.icon;
			const nodeName = credentialType.displayName.replace(/ API$/, '');
			const httpNodeClone = new httpNode.constructor().getNodeType(4.1);
			const { docsUrl, apiBaseUrl } = credentialType.httpRequestNodeVariant;

			httpNodeClone.hidden = hasSupportedNodes;
			httpNodeClone.description.codex = httpNode.description.codex;
			httpNodeClone.description.credentials = [{ name: credentialType.name, required: true }];
			httpNodeClone.description.name = `${httpNode.description.name}:${credentialType.name}`;
			httpNodeClone.description.displayName = nodeName;
			httpNodeClone.description.icon = credentialType.icon;
			httpNodeClone.description.iconUrl = credentialType.iconUrl;
			httpNodeClone.description.badgeIcon = httpIcon;
			httpNodeClone.description.defaults.name = `${nodeName} HTTP Request`;
			httpNodeClone.description.description = 'Make raw HTTP request';
			httpNodeClone.description.codex.categories = ['Core Variant Nodes'];
			httpNodeClone.description.codex.alias = [];
			httpNodeClone.description.codex.subcategories = {
				'Core Variant Nodes': ['Http'],
			};
			httpNodeClone.description.properties = httpNodeClone.description.properties.map((prop) => {
				switch (prop.name) {
					case 'authentication':
						return { ...prop, type: 'hidden', default: 'predefinedCredentialType' };
					case 'nodeCredentialType':
						return { ...prop, type: 'hidden', default: credentialType.name };
					case 'url':
						return { ...prop, default: apiBaseUrl, placeholder: `e.g. ${apiBaseUrl}` };
					default:
						return prop;
				}
			});

			httpNodeClone.description.properties.splice(1, 0, {
				displayName: `Use the <a target="_blank" href="${docsUrl}">${nodeName} docs</a> to construct your request. We'll take care of the authentication part if you add a ${nodeName} credential below.`,
				name: 'httpVariantWarning',
				type: 'notice',
			});

			return httpNodeClone.description;
		});
}

(async () => {
	const loader = new PackageDirectoryLoader(packageDir);
	await loader.loadAll();

	const credentialTypes = Object.values(loader.credentialTypes).map((data) => data.type);

	const loaderNodeTypes = Object.values(loader.nodeTypes);
	const knownCredentials = loader.known.credentials;

	const definedMethods = loaderNodeTypes.reduce((acc, cur) => {
		NodeHelpers.getVersionedNodeTypeAll(cur.type).forEach((type) => {
			const methods = type.description?.__loadOptionsMethods;

			if (!methods) return;

			const { name } = type.description;

			if (acc[name]) {
				acc[name] = [...new Set([...acc[name], ...methods])];
				return;
			}

			acc[name] = methods;
		});

		return acc;
	}, {});

	const httpRequestNodeType = loader.nodeTypes['n8n-nodes-base.httpRequest'].type;
	const httpVariantNodes = generateHttpRequestVariantNodes(
		knownCredentials,
		loader.credentialTypes,
		httpRequestNodeType,
		4.1, // If a new HTTP request node version releases, keep v4.1 variants for compatibility
	);

	const nodeTypes = loaderNodeTypes
		.map((data) => {
			const nodeType = NodeHelpers.getVersionedNodeType(data.type);
			NodeHelpers.applySpecialNodeParameters(nodeType);
			return data.type;
		})
		.flatMap((nodeType) =>
			NodeHelpers.getVersionedNodeTypeAll(nodeType).map((item) => {
				const { __loadOptionsMethods, ...rest } = item.description;
				return rest;
			}),
		)
		.concat(httpVariantNodes);

	const referencedMethods = findReferencedMethods(nodeTypes);

	await Promise.all([
		writeJSON('types/credentials.json', credentialTypes),
		writeJSON('types/nodes.json', nodeTypes),
		writeJSON('methods/defined.json', definedMethods),
		writeJSON('methods/referenced.json', referencedMethods),
	]);
})();
